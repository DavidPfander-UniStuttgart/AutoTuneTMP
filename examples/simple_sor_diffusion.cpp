#include <iostream>
#include <vector>
#include <cmath>
#include <chrono>
#include "tga.h"

#include "simple_sor_diffusion.hpp"

#include "autotune/autotune.hpp"
#include "autotune/continuous_parameter.hpp"
#include "autotune/tuners/line_search.hpp"

AUTOTUNE_DECLARE_DEFINE_KERNEL(double(std::vector<double> &, std::vector<double> &, 
                                      const std::vector<double> &, const std::vector<double> &, 
                                      const double &, double &, double &, double &, size_t &, size_t &),
                                      SORDiffusion)

void InitGrid(std::vector<double> &rhs) {
  for (int y = 0; y < dimY; ++y ) {
    for (int x = 0; x < dimX; ++x) {
      int i = x + (y+1)*(dimX + 2) + 1;
      rhs[i] = -.5*sin(hx*x)*sin(hy*y);
    }
  }
}

size_t SORFlops (size_t iter) {
  return iter*dimX*dimY*12 + (iter/INNER_LOOP)*dimX*dimY*12;
}

size_t SORSolve(std::vector<double> &grid, const std::vector<double> &rhs, const double &eps) {
  size_t itermax = 1<<30;
  size_t iter;
  double res, rate, time;
  
  std::vector<double> grid_r((dimX+2)*(dimY+2)/2, 0.0);
  std::vector<double> grid_b((dimX+2)*(dimY+2)/2, 0.0);
  
  std::vector<double> rhs_r((dimX+2)*(dimY+2)/2);
  std::vector<double> rhs_b((dimX+2)*(dimY+2)/2);
  for (int y = 1; y <= dimY; ++y ) {
    for (int x = 0; x < dimX/2; ++x) {
      int i = x + y*(dimX/2 + 1);
      if (y%2 == 1) {
        rhs_r[i] = rhs[2*i + 1];
        rhs_b[i+1] = rhs[2*i + 2];
      } else {
        rhs_b[i] = rhs[2*i + 1];
        rhs_r[i+1] = rhs[2*i + 2];
      }
    }
  }
  
  autotune::countable_set parameters;
  autotune::countable_continuous_parameter p1("OMEGA", 1.99, 0.005, 1.80, 1.995);
  autotune::fixed_set_parameter<int> p2("BLOCKSIZEX", {1, 2, 4, 8});
  autotune::fixed_set_parameter<int> p3("BLOCKSIZEY", {1, 2, 4, 8});
  autotune::fixed_set_parameter<int> p4("NUMTHREADS", {1, 2, 4});
  parameters.add_parameter(p1);
  parameters.add_parameter(p2);
  parameters.add_parameter(p3);
  parameters.add_parameter(p4);
  
  auto rate_functor = [&rate, &time, &iter]() {
    std::cout << rate << " in " << time << "s : " << iter << std::endl;
    return time/(rate*iter);
  };
  autotune::SORDiffusion.set_kernel_duration_functor(rate_functor);
  
  std::function<bool(double)> test_result = [eps](double res) -> bool {
    /* tests values generated by kernel */
    return res <= eps;
    //return true;
  };
  
  size_t line_search_iterations = 4;
  autotune::tuners::line_search tuner(autotune::SORDiffusion, parameters,
                                      line_search_iterations, 1);
  tuner.setup_test(test_result);
  autotune::countable_set optimal_parameters = tuner.tune(grid_r, grid_b, rhs_r, rhs_b, eps, res, rate, time, iter, itermax);
  autotune::SORDiffusion.set_parameter_values(optimal_parameters);
  
  std::cout << "Done tuning" << std::endl;
  
  for (int i = 0; i < 10; ++i) {
    autotune::SORDiffusion(grid_r, grid_b, rhs_r, rhs_b, eps, res, rate, time, iter, itermax);
    std::cout << "Convergence rate: " << rate << std::endl;
    std::cout << "Solved in " << iter << " iterations" << std::endl;
    std::cout << "Residual: " << res << std::endl << std::endl;
    std::cout << "Finished in " << time << "s" << std::endl;
    std::cout << "Executed " << SORFlops(iter) << " FLOPs" << std::endl;
    std::cout << "Achieved " << double(SORFlops(iter))*1e-9/time << " GFLOP/s" << std::endl;
  }
  
  for (int y = 1; y <= dimY; ++y ) {
    for (int x = 0; x < dimX/2; ++x) {
      int i = x + y*(dimX/2 + 1);
      if (y%2 == 1) {
        grid[2*i + 1] = grid_r[i];
        grid[2*i + 2] = grid_b[i+1];
      } else {
        grid[2*i + 1] = grid_b[i];
        grid[2*i + 2] = grid_r[i+1];
      }
    }
  }
  return iter;
}

int main (void) {
  autotune::SORDiffusion.set_verbose(true);
  auto builder = autotune::SORDiffusion.get_builder_as<cppjit::builder::gcc>();
  //builder->set_verbose(true);
  autotune::SORDiffusion.set_source_dir("examples/kernel_sor_diffusion");
  builder->set_include_paths(
      "-IAutoTuneTMP_install/include "
      "-IVc_install/include "
      "-Iboost_install/include");
  builder->set_cpp_flags("-Wall -Wextra -std=c++17 -march=native -mtune=native "
                         "-O3 -g -ffast-math -fopenmp -fPIC -fno-gnu-unique");
  builder->set_link_flags("-shared -g -fopenmp -fno-gnu-unique");

  
  std::vector<double> grid((dimX+2)*(dimY+2), 0.0);
  std::vector<double> rhs ((dimX+2)*(dimY+2), 0.0);
  
  InitGrid(rhs);
    
  SORSolve(grid, rhs, eps);
  
  /*RGB_t *img = new RGB_t[dimX*dimY];
  double gmin, gmax;
  gmin = gmax = grid[0];
  for (int i = 0; i < dimX*dimY; ++i) {
    if (gmin > grid[i]) gmin = grid[i];
    if (gmax < grid[i]) gmax = grid[i];
  }
   for (int y = 0; y < dimY; ++y ) {
    for (int x = 0; x < dimX; ++x) {
      int i = x + (y+1)*(dimX + 2) + 1;
      int val = (int)(255 * (grid[i] - gmin)/(gmax-gmin));
      img[x + y*dimX] = ColorRGB(val, val, val);
    }
  }
  write_tga("SOR_Diffusion.tga", img, dimX, dimY);
  delete[] img;*/
  
  return 0;
}
